{% extends "base.html" %}
{% block title %}JSON {{ page.title }}{% endblock %}

{% block content %}
<div class="container mt-4">
  <h1 id="schemaPageTitle">{{ page.title }}</h1>

  <div class="accordion" id="schemaAccordion">
    <div class="accordion-item">
      <h2 class="accordion-header" id="schemaHeadingTitle">
        <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#schemaCollapseTitle" aria-expanded="true" aria-controls="schemaCollapseTitle">
          Titre
        </button>
      </h2>
      <div id="schemaCollapseTitle" class="accordion-collapse collapse show" aria-labelledby="schemaHeadingTitle" data-bs-parent="#schemaAccordion">
        <div class="accordion-body" id="schemaResultTitle"></div>
      </div>
    </div>
    <div class="accordion-item">
      <h2 class="accordion-header" id="schemaHeadingDesc">
        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#schemaCollapseDesc" aria-expanded="false" aria-controls="schemaCollapseDesc">
          Description
        </button>
      </h2>
      <div id="schemaCollapseDesc" class="accordion-collapse collapse" aria-labelledby="schemaHeadingDesc" data-bs-parent="#schemaAccordion">
        <div class="accordion-body" id="schemaResultDescription"></div>
      </div>
    </div>
    <div class="accordion-item">
      <h2 class="accordion-header" id="schemaHeadingMarkdown">
        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#schemaCollapseMarkdown" aria-expanded="false" aria-controls="schemaCollapseMarkdown">
          Markdown
        </button>
      </h2>
      <div id="schemaCollapseMarkdown" class="accordion-collapse collapse" aria-labelledby="schemaHeadingMarkdown" data-bs-parent="#schemaAccordion">
        <div class="accordion-body" id="schemaResultMarkdown"></div>
      </div>
    </div>
    <div class="accordion-item">
      <h2 class="accordion-header" id="schemaHeadingSchema">
        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#schemaCollapseSchema" aria-expanded="false" aria-controls="schemaCollapseSchema">
          JSON Schema
        </button>
      </h2>
      <div id="schemaCollapseSchema" class="accordion-collapse collapse" aria-labelledby="schemaHeadingSchema" data-bs-parent="#schemaAccordion">
        <div class="accordion-body">
          <div id="schemaResultTree" class="mb-2 accordion"></div>
          <div id="schemaResultGraph" class="mb-2"></div>
          <pre class="mb-0 small" id="schemaResultJson"></pre>
        </div>
      </div>
    </div>
  </div>

  <div class="mt-3 d-flex gap-2">
    <button id="schemaEditBtn" class="btn btn-secondary" type="button">Éditer</button>
    <button id="schemaRenameTitleBtn" class="btn btn-outline-primary" type="button">Renommer le schéma</button>
    <button id="schemaBrowseBtn" class="btn btn-outline-secondary" type="button">Parcourir le schéma</button>
    <a href="{{ url_for('main.docx_schema_pages') }}" class="btn btn-outline-secondary">Retour</a>
  </div>

  <div class="modal fade" id="schemaEditModal" tabindex="-1" aria-labelledby="schemaEditLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="schemaEditLabel">Éditer le schéma</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <textarea id="schemaEditTextarea" class="form-control" rows="12"></textarea>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
          <button type="button" id="schemaEditSaveBtn" class="btn btn-primary">Enregistrer</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Modal de parcours de schéma -->
<div class="modal fade" id="schemaPointerBrowseModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Parcourir le schéma</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fermer"></button>
      </div>
      <div class="modal-body">
        <div class="mb-2"><input id="schemaPointerSearch" class="form-control form-control-sm" placeholder="Rechercher un champ ou chemin..."></div>
        <div id="schemaPointerTree" class="small"></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fermer</button>
      </div>
    </div>
  </div>
</div>

<style>
  #schemaResultJson, #schemaResultTree, #schemaResultGraph { overflow-x: auto; }
  #schemaResultGraph svg { height: 400px; }
  @media (max-width: 576px) { #schemaResultGraph svg { height: 300px; } }
</style>
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  let schemaData = {{ page.json_schema | tojson }};
  try {
    if (typeof schemaData === 'string') {
      const t = schemaData.trim();
      if ((t.startsWith('{') && t.endsWith('}')) || (t.startsWith('[') && t.endsWith(']'))) {
        schemaData = JSON.parse(t);
      }
    }
    if (schemaData && typeof schemaData === 'object' && typeof schemaData.schema === 'string') {
      const t = schemaData.schema.trim();
      if ((t.startsWith('{') && t.endsWith('}')) || (t.startsWith('[') && t.endsWith(']'))) {
        schemaData = JSON.parse(t);
      }
    }
  } catch {}
  const markdownData = {{ page.markdown_content | tojson }};
  const pageId = {{ page.id }};
  const titleEl = document.getElementById('schemaResultTitle');
  const descEl = document.getElementById('schemaResultDescription');
  const schemaEl = document.getElementById('schemaResultJson');
  const schemaTreeEl = document.getElementById('schemaResultTree');
  const schemaGraphEl = document.getElementById('schemaResultGraph');
  const markdownEl = document.getElementById('schemaResultMarkdown');
  const pageTitleEl = document.getElementById('schemaPageTitle');
  const editBtn = document.getElementById('schemaEditBtn');
  const editModalEl = document.getElementById('schemaEditModal');
  const editTextarea = document.getElementById('schemaEditTextarea');
  const editSaveBtn = document.getElementById('schemaEditSaveBtn');
  const planFormEl = document.getElementById('planCadreForm');
  const browseBtn = document.getElementById('schemaBrowseBtn');
  const browseModalEl = document.getElementById('schemaPointerBrowseModal');
  const browseTree = document.getElementById('schemaPointerTree');
  const browseModal = (typeof bootstrap !== 'undefined') ? new bootstrap.Modal(browseModalEl) : null;
  let pendingMove = null; // { srcPtr, key, newKey }
  function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }
  function buildPointerTree(schema, basePtr='#') {
    const root = document.createElement('div');
    root.className = 'list-group';
    function nodeRow(label, ptr) {
      const a = document.createElement('a');
      a.href = '#';
      a.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
      a.innerHTML = `<span>${escapeHtml(label)}</span><code class="ms-2">${escapeHtml(ptr)}</code>`;
      a.addEventListener('click', async (e) => {
        e.preventDefault();
        if (pendingMove) {
          try {
            const dst = getByPointer(schemaData, ptr);
            const isObject = !!(dst && (dst.type === 'object' || dst.properties));
            if (!isObject) { alert('Sélectionnez un objet comme destination.'); return; }
            const newKey = (pendingMove.newKey && pendingMove.newKey.trim()) ? pendingMove.newKey.trim() : pendingMove.key;
            moveProperty(pendingMove.srcPtr, pendingMove.key, ptr, newKey);
            await persistChanges();
            pendingMove = null;
            renderAll();
            browseModal.hide();
          } catch (err) {
            alert('Déplacement impossible: ' + (err && err.message ? err.message : ''));
          }
        } else {
          browseModal.hide();
        }
      });
      return a;
    }
    function walk(n, path, container) {
      if (!n || typeof n !== 'object') return;
      const t = n.type;
      if (t === 'object' && n.properties) {
        Object.entries(n.properties).forEach(([k, v]) => {
          const ptr = `${path}/properties/${k}`;
          const row = nodeRow(`${v.title || k} (objet)`, ptr);
          container.appendChild(row);
          const child = document.createElement('div');
          child.className = 'ms-3 border-start ps-2';
          container.appendChild(child);
          walk(v, ptr, child);
        });
      } else if (t === 'array' && n.items) {
        const ptr = `${path}/items`;
        const row = nodeRow(`${n.title || 'Éléments'} [liste]`, ptr);
        container.appendChild(row);
        const child = document.createElement('div');
        child.className = 'ms-3 border-start ps-2';
        container.appendChild(child);
        walk(n.items, ptr, child);
      } else {
        const row = nodeRow(`${n.title || (t || 'valeur')} (${t||'string'})`, path);
        container.appendChild(row);
      }
    }
    walk(schema, basePtr, root);
    return root;
  }
  function filterPointerTree(root, q) {
    const query = (q||'').trim().toLowerCase();
    const rows = root.querySelectorAll('a.list-group-item');
    rows.forEach(a => {
      const t = (a.innerText || a.textContent || '').toLowerCase();
      a.style.display = (!query || t.includes(query)) ? '' : 'none';
    });
  }
  let markdownOrderMap = {};
  const normalizedMarkdown = normalizeName(markdownData || '');
  function normalizeName(str) {
    return (str || '')
      .toString()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-zA-Z0-9]+/g, ' ')
      .trim()
      .toLowerCase();
  }
  function buildMarkdownOrderMap(markdown) {
    try {
      const tokens = marked.lexer(markdown || '');
      const map = { root: [] };
      const stack = [];
      function addOrder(path, name) {
        const key = path || 'root';
        if (!map[key]) map[key] = [];
        map[key].push(name);
      }
      function process(tok) {
        for (const t of tok) {
          if (t.type === 'heading') {
            stack.length = t.depth - 1;
            stack[t.depth - 1] = normalizeName(t.text);
            const parent = stack.slice(0, -1).join('.') || 'root';
            addOrder(parent, stack[t.depth - 1]);
          } else if (t.type === 'list') {
            if (stack.length === 0) continue;
            const parent = stack.join('.') || 'root';
            t.items.forEach(item => {
              const name = normalizeName(item.text);
              addOrder(parent, name);
              if (item.tokens) {
                stack.push(name);
                process(item.tokens);
                stack.pop();
              }
            });
          }
        }
      }
      process(tokens);
      return map;
    } catch (e) { return { root: [] }; }
  }
  function getMdOrder(path) {
    const key = normalizeName(path.replace(/\[[0-9]+\]/g, '')) || 'root';
    return markdownOrderMap[key] || [];
  }
  function getMarkdownIndex(name) {
    const idx = normalizedMarkdown.indexOf(name);
    return idx === -1 ? Number.MAX_SAFE_INTEGER : idx;
  }

  function normalizePlanSchema(node) {
    if (!node || typeof node !== 'object') return node;

    const defs = node.$defs || {};

    function getFromPointer(ptr) {
      // Supports pointers like '#/$defs/name/subpath'
      if (!ptr || typeof ptr !== 'string' || !ptr.startsWith('#/')) return null;
      const parts = ptr.slice(2).split('/');
      let cur = node;
      for (const p of parts) {
        const key = p.replace(/~1/g, '/').replace(/~0/g, '~');
        if (cur && typeof cur === 'object' && key in cur) cur = cur[key];
        else return null;
      }
      return cur || null;
    }

    function clone(obj) { return JSON.parse(JSON.stringify(obj)); }

    function resolveRef(n) {
      if (!n || typeof n !== 'object') return n;
      if (n.$ref) {
        const target = getFromPointer(n.$ref) || null;
        if (target) {
          const merged = Object.assign({}, clone(target));
          for (const [k, v] of Object.entries(n)) {
            if (k === '$ref') continue;
            merged[k] = v;
          }
          return merged;
        }
      }
      return n;
    }

    function walk(n) {
      if (!n || typeof n !== 'object') return {};

      // Apply $ref resolution first
      if (n.$ref) {
        return walk(resolveRef(n));
      }

      const keys = Object.keys(n);
      if (!n.type && !n.properties && !n.items && !n.champs && !n.parts && keys.length === 1 && !['title','description'].includes(keys[0])) {
        const key = keys[0];
        const inner = walk(n[key]);
        if (inner && typeof inner === 'object' && !inner.title) inner.title = key;
        return inner;
      }

      if (n.parts) {
        const props = {};
        for (const [k, v] of Object.entries(n.parts)) {
          props[k] = walk(v);
        }
        const out = { type: 'object', properties: props };
        if (n.title) out.title = n.title;
        if (n.description) out.description = n.description;
        return out;
      }

      if (n.fields) {
        const props = {};
        for (const [k, v] of Object.entries(n.fields)) {
          props[k] = walk(v);
        }
        const out = { type: 'object', properties: props };
        if (n.title) out.title = n.title;
        if (n.description) out.description = n.description;
        return out;
      }

      if (n.type === 'object' && n.properties) {
        const props = {};
        for (const [k, v] of Object.entries(n.properties)) {
          props[k] = walk(resolveRef(v));
        }
        const out = { type: 'object', properties: props };
        if (n.title) out.title = n.title;
        if (n.description) out.description = n.description;
        return out;
      }

      if (n.type === 'array') {
        let items = n.items;
        if (Array.isArray(items)) {
          items = items[0];
        }
        if (items) {
          items = walk(resolveRef(items));
        }
        const out = { type: 'array', items };
        if (n.title) out.title = n.title;
        if (n.description) out.description = n.description;
        return out;
      }

      const out = { type: n.type || 'string' };
      if (n.titre || n.title) out.title = n.titre || n.title;
      if (n.description) out.description = n.description;
      return out;
    }
    return walk(node);
  }

  function renderPlanCadreForm(schema, parent, path='root') {
    if (!schema || !parent) return;
    if (schema.type === 'object' && schema.properties) {
      const entries = Object.entries(schema.properties);
      const mdOrder = getMdOrder(path);
      const customOrder = ((getByPointer(schemaData, ptr) || {}).x_order) || [];
      entries.sort(([ak, av], [bk, bv]) => {
        const ia = customOrder.indexOf(ak);
        const ib = customOrder.indexOf(bk);
        if (ia !== -1 || ib !== -1) return (ia === -1 ? Number.MAX_SAFE_INTEGER : ia) - (ib === -1 ? Number.MAX_SAFE_INTEGER : ib);
        const nameA = normalizeName(av.title || ak);
        const nameB = normalizeName(bv.title || bk);
        const mdIa = mdOrder.indexOf(nameA);
        const mdIb = mdOrder.indexOf(nameB);
        const posA = mdIa !== -1 ? mdIa : getMarkdownIndex(nameA);
        const posB = mdIb !== -1 ? mdIb : getMarkdownIndex(nameB);
        return posA - posB;
      });
      const container = path === 'root' ? parent : document.createElement('div');
      if (path !== 'root') {
        container.className = 'border rounded p-2 mb-3';
        const legend = document.createElement('h6');
        legend.textContent = schema.title || path;
        legend.className = 'fw-bold';
        container.appendChild(legend);
      }
      for (const [key, prop] of entries) {
        const childName = normalizeName(prop.title || key);
        const childPath = path === 'root' ? childName : `${path}.${childName}`;
        renderPlanCadreForm(prop, container, childPath);
      }
      if (path !== 'root') parent.appendChild(container);
      return;
    }
    if (schema.type === 'array' && schema.items) {
      const container = document.createElement('div');
      container.className = 'mb-3';

      const label = document.createElement('label');
      label.className = 'form-label';
      label.textContent = schema.title || path;
      container.appendChild(label);

      const list = document.createElement('div');
      list.className = 'd-flex flex-column gap-2';
      container.appendChild(list);

      const itemName = normalizeName(schema.items.title || schema.title || path);
      const itemPath = path === 'root' ? itemName : `${path}.${itemName}`;

      function addItem() {
        if (schema.items.type === 'object') {
          const wrapper = document.createElement('div');
          wrapper.className = 'border rounded p-2 position-relative';
          renderPlanCadreForm(schema.items, wrapper, itemPath);
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'btn btn-outline-danger btn-sm position-absolute top-0 end-0 remove-form-array-item';
          btn.innerHTML = '<i class="bi bi-x"></i>';
          btn.addEventListener('click', () => wrapper.remove());
          wrapper.appendChild(btn);
          list.appendChild(wrapper);
        } else {
          const wrapper = document.createElement('div');
          wrapper.className = 'input-group';
          const input = document.createElement('input');
          input.className = 'form-control';
          input.name = `${path}[]`;
          wrapper.appendChild(input);
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'btn btn-outline-danger remove-form-array-item';
          btn.innerHTML = '<i class="bi bi-x"></i>';
          btn.addEventListener('click', () => wrapper.remove());
          wrapper.appendChild(btn);
          list.appendChild(wrapper);
        }
      }

      const addBtn = document.createElement('button');
      addBtn.type = 'button';
      addBtn.className = 'btn btn-outline-primary btn-sm add-form-array-item';
      addBtn.textContent = 'Ajouter';
      addBtn.addEventListener('click', addItem);
      container.appendChild(addBtn);

      parent.appendChild(container);
      addItem();
      return;
    }

    const field = document.createElement('div');
    field.className = 'mb-3';
    const label = document.createElement('label');
    label.className = 'form-label';
    label.setAttribute('for', path);
    label.textContent = schema.title || path;
    const input = document.createElement('input');
    input.className = 'form-control';
    input.id = path;
    input.name = path;
    if (schema.type === 'number' || schema.type === 'integer') input.type = 'number';
    else input.type = 'text';
    field.appendChild(label);
    field.appendChild(input);
    parent.appendChild(field);
  }

  function renderSchemaAccordion(schema, parent, name='root', path='root', required=[], ptr='#') {
    if (!schema || !parent) return;
    const type = schema.type || (schema.$ref ? schema.$ref : 'any');
    const isRequired = required.includes(name);
    const itemId = `acc-${path.replace(/[^a-z0-9]/gi, '-')}`;

    const item = document.createElement('div');
    item.className = 'accordion-item';

    const header = document.createElement('h2');
    header.className = 'accordion-header';
    header.id = `${itemId}-head`;

    const button = document.createElement('button');
    button.className = 'accordion-button collapsed';
    button.type = 'button';
    button.setAttribute('data-bs-toggle', 'collapse');
    button.setAttribute('data-bs-target', `#${itemId}-body`);
    button.setAttribute('aria-expanded', 'false');
    button.setAttribute('aria-controls', `${itemId}-body`);
    const displayName = (schema && schema.title) ? schema.title : name;
    button.textContent = `${displayName}${isRequired ? '*' : ''} (${type})`;
    header.appendChild(button);
    item.appendChild(header);

    const collapse = document.createElement('div');
    collapse.id = `${itemId}-body`;
    collapse.className = 'accordion-collapse collapse';
    collapse.setAttribute('aria-labelledby', `${itemId}-head`);

    const body = document.createElement('div');
    body.className = 'accordion-body';
    collapse.appendChild(body);
    item.appendChild(collapse);
    parent.appendChild(item);

    if (schema.description) {
      const desc = document.createElement('div');
      desc.textContent = schema.description;
      body.appendChild(desc);
    }

    if (schema.type === 'object' && schema.properties) {
      const inner = document.createElement('div');
      inner.className = 'accordion';
      inner.id = `${itemId}-inner`;
      // Toolbar for object-level actions (add property)
      const toolbar = document.createElement('div');
      toolbar.className = 'mb-2 d-flex gap-2';
      const addPropBtn = document.createElement('button');
      addPropBtn.type = 'button';
      addPropBtn.className = 'btn btn-sm btn-outline-primary';
      addPropBtn.innerHTML = '<i class="bi bi-plus-circle"></i> Ajouter un champ';
      addPropBtn.addEventListener('click', async () => {
        const key = prompt('Nom du champ (clé JSON):');
        if (!key) return;
        const title = prompt('Titre du champ (affichage):', key);
        try {
          addObjectProperty(ptr, key, { type: 'string', title: title || key });
          await persistChanges();
          renderAll();
        } catch (e) { alert('Impossible d\'ajouter le champ.'); }
      });
      toolbar.appendChild(addPropBtn);

      const addObjBtn = document.createElement('button');
      addObjBtn.type = 'button';
      addObjBtn.className = 'btn btn-sm btn-outline-primary';
      addObjBtn.innerHTML = '<i class="bi bi-node-plus"></i> Ajouter objet';
      addObjBtn.addEventListener('click', async () => {
        const key = prompt('Nom du champ (clé JSON) pour l\'objet:');
        if (!key) return;
        const title = prompt('Titre de l\'objet:', key);
        try {
          addObjectProperty(ptr, key, { type: 'object', title: title || key, properties: {} });
          await persistChanges();
          renderAll();
        } catch (e) { alert('Impossible d\'ajouter l\'objet.'); }
      });
      toolbar.appendChild(addObjBtn);

      const addArrayObjBtn = document.createElement('button');
      addArrayObjBtn.type = 'button';
      addArrayObjBtn.className = 'btn btn-sm btn-outline-primary';
      addArrayObjBtn.innerHTML = '<i class="bi bi-braces"></i> Ajouter liste d’objets';
      addArrayObjBtn.addEventListener('click', async () => {
        const key = prompt('Nom du champ (clé JSON) pour la liste:');
        if (!key) return;
        const title = prompt('Titre de la liste:', key);
        const itemTitle = prompt('Titre des éléments:', 'Élément');
        try {
          addObjectProperty(ptr, key, { type: 'array', title: title || key, items: { type: 'object', title: itemTitle || 'Élément', properties: {} } });
          await persistChanges();
          renderAll();
        } catch (e) { alert('Impossible d\'ajouter la liste.'); }
      });
      toolbar.appendChild(addArrayObjBtn);

      const addArrayStrBtn = document.createElement('button');
      addArrayStrBtn.type = 'button';
      addArrayStrBtn.className = 'btn btn-sm btn-outline-primary';
      addArrayStrBtn.innerHTML = '<i class="bi bi-card-list"></i> Ajouter liste de chaînes';
      addArrayStrBtn.addEventListener('click', async () => {
        const key = prompt('Nom du champ (clé JSON) pour la liste:');
        if (!key) return;
        const title = prompt('Titre de la liste:', key);
        try {
          addObjectProperty(ptr, key, { type: 'array', title: title || key, items: { type: 'string', title: 'Entrée' } });
          await persistChanges();
          renderAll();
        } catch (e) { alert('Impossible d\'ajouter la liste.'); }
      });
      toolbar.appendChild(addArrayStrBtn);
      const editObjTitleBtn = document.createElement('button');
      editObjTitleBtn.type = 'button';
      editObjTitleBtn.className = 'btn btn-sm btn-outline-secondary';
      editObjTitleBtn.innerHTML = '<i class="bi bi-type"></i> Modifier titre (objet)';
      editObjTitleBtn.addEventListener('click', async () => {
        const cur = schema.title || '';
        const t = prompt('Titre de l\'objet:', cur);
        if (t === null) return;
        try { setNodeTitle(ptr, t); await persistChanges(); renderAll(); } catch (e) { alert('Impossible de modifier le titre.'); }
      });
      toolbar.appendChild(editObjTitleBtn);
      body.appendChild(toolbar);
      body.appendChild(inner);
      const childRequired = schema.required || [];
      const entries = Object.entries(schema.properties);
      const mdOrder = getMdOrder(path);
      const customOrder = ((getByPointer(schemaData, ptr) || {}).x_order) || [];
      entries.sort(([ak, av], [bk, bv]) => {
        const ia = customOrder.indexOf(ak);
        const ib = customOrder.indexOf(bk);
        if (ia !== -1 || ib !== -1) return (ia === -1 ? Number.MAX_SAFE_INTEGER : ia) - (ib === -1 ? Number.MAX_SAFE_INTEGER : ib);
        const nameA = normalizeName(av.title || ak);
        const nameB = normalizeName(bv.title || bk);
        const mdIa = mdOrder.indexOf(nameA);
        const mdIb = mdOrder.indexOf(nameB);
        const posA = mdIa !== -1 ? mdIa : getMarkdownIndex(nameA);
        const posB = mdIb !== -1 ? mdIb : getMarkdownIndex(nameB);
        return posA - posB;
      });
      for (const [key, val] of entries) {
        const childName = normalizeName(val.title || key);
        const childPath = path === 'root' ? childName : `${path}.${childName}`;
        const childPtr = `${ptr}/properties/${key}`;
        // Wrap property and actions to enable drag-and-drop
        const wrapper = document.createElement('div');
        wrapper.className = 'prop-block mb-1';
        wrapper.dataset.key = key;
        wrapper.setAttribute('draggable', 'true');
        inner.appendChild(wrapper);
        const childContainer = document.createElement('div');
        wrapper.appendChild(childContainer);
        renderSchemaAccordion(val, childContainer, key, childPath, childRequired, childPtr);
        const actionRow = document.createElement('div');
        actionRow.className = 'px-3 pb-2 d-flex gap-2';
        const renameBtn = document.createElement('button');
        renameBtn.type = 'button';
        renameBtn.className = 'btn btn-sm btn-outline-secondary';
        renameBtn.innerHTML = '<i class="bi bi-pencil"></i> Renommer';
        renameBtn.addEventListener('click', async () => {
          const newKey = prompt('Nouveau nom de champ (clé JSON):', key);
          if (!newKey || newKey === key) return;
          try {
            renameObjectProperty(ptr, key, newKey);
            await persistChanges();
            renderAll();
          } catch (e) { alert('Impossible de renommer: ' + (e && e.message ? e.message : '')); }
        });
        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.className = 'btn btn-sm btn-outline-danger';
        deleteBtn.innerHTML = '<i class="bi bi-trash"></i> Supprimer';
        deleteBtn.addEventListener('click', async () => {
          if (!confirm(`Supprimer le champ "${key}" ?`)) return;
          try {
            deleteObjectProperty(ptr, key);
            await persistChanges();
            renderAll();
          } catch (e) { alert('Suppression impossible: ' + (e && e.message ? e.message : '')); }
        });
        const typeBtn = document.createElement('button');
        typeBtn.type = 'button';
        typeBtn.className = 'btn btn-sm btn-outline-secondary';
        typeBtn.innerHTML = '<i class="bi bi-sliders"></i> Modifier type';
        typeBtn.addEventListener('click', async () => {
          const t = prompt('Type (string, number, integer, boolean, object, array):', (val && val.type) || 'string');
          if (!t) return;
          try {
            setNodeType(childPtr, t.trim());
            await persistChanges();
            renderAll();
          } catch (e) { alert('Modification de type impossible: ' + (e && e.message ? e.message : '')); }
        });

        const descBtn = document.createElement('button');
        descBtn.type = 'button';
        descBtn.className = 'btn btn-sm btn-outline-secondary';
        descBtn.innerHTML = '<i class="bi bi-card-text"></i> Modifier description';
        descBtn.addEventListener('click', async () => {
          const cur = (val && val.description) || '';
          const d = prompt('Nouvelle description:', cur);
          if (d === null) return;
          try {
            setNodeDescription(childPtr, d);
            await persistChanges();
            renderAll();
          } catch (e) { alert('Modification description impossible.'); }
        });

        const titleBtn = document.createElement('button');
        titleBtn.type = 'button';
        titleBtn.className = 'btn btn-sm btn-outline-secondary';
        titleBtn.innerHTML = '<i class="bi bi-type"></i> Modifier titre';
        titleBtn.addEventListener('click', async () => {
          const cur = (val && (val.title || val.titre)) || '';
          const t = prompt('Nouveau titre:', cur);
          if (t === null) return;
          try { setNodeTitle(childPtr, t); await persistChanges(); renderAll(); } catch (e) { alert('Modification titre impossible.'); }
        });

        const moveBtn = document.createElement('button');
        moveBtn.type = 'button';
        moveBtn.className = 'btn btn-sm btn-outline-primary';
        moveBtn.innerHTML = '<i class="bi bi-arrows-move"></i> Déplacer…';
        moveBtn.addEventListener('click', () => {
          const nk = prompt('Nouveau nom (laisser vide pour conserver):', key) || key;
          pendingMove = { srcPtr: ptr, key, newKey: nk };
          if (browseModal) {
            browseTree.innerHTML = '';
            const t = buildPointerTree(currentSchema, '#');
            browseTree.appendChild(t);
            const browseSearch = document.getElementById('schemaPointerSearch');
            if (browseSearch) {
              browseSearch.value = '';
              browseSearch.oninput = () => filterPointerTree(browseTree, browseSearch.value);
            }
            browseModal.show();
          }
        });

        actionRow.appendChild(renameBtn);
        actionRow.appendChild(deleteBtn);
        actionRow.appendChild(typeBtn);
        actionRow.appendChild(descBtn);
        actionRow.appendChild(titleBtn);
        actionRow.appendChild(moveBtn);
        wrapper.appendChild(actionRow);
        wrapper.addEventListener('dragstart', (ev) => { ev.dataTransfer.setData('text/plain', key); wrapper.classList.add('dragging'); });
        wrapper.addEventListener('dragend', () => { wrapper.classList.remove('dragging'); });
      }
      // Enable drop to reorder properties within this object
      inner.addEventListener('dragover', (ev) => { ev.preventDefault(); });
      inner.addEventListener('drop', async (ev) => {
        ev.preventDefault();
        const srcKey = ev.dataTransfer.getData('text/plain');
        const target = ev.target.closest('.prop-block');
        if (!srcKey || !target) return;
        const srcEl = inner.querySelector(`.prop-block[data-key="${srcKey}"]`);
        if (!srcEl || srcEl === target) return;
        inner.insertBefore(srcEl, target);
        const keys = Array.from(inner.querySelectorAll('.prop-block')).map(el => el.dataset.key);
        try {
          const objNode = getByPointer(schemaData, ptr) || {};
          objNode.x_order = keys;
          await persistChanges();
          renderAll();
        } catch (e) { alert('Réordonnancement impossible: ' + (e && e.message ? e.message : '')); }
      });
    } else if (schema.type === 'array' && schema.items) {
      const list = document.createElement('div');
      list.className = 'array-container';
      body.appendChild(list);
      const itemsPtr = `${ptr}/items`;
      const arrToolbar = document.createElement('div');
      arrToolbar.className = 'mb-2 d-flex gap-2';
      const itemsTypeBtn = document.createElement('button');
      itemsTypeBtn.type = 'button';
      itemsTypeBtn.className = 'btn btn-sm btn-outline-secondary';
      itemsTypeBtn.innerHTML = '<i class="bi bi-braces"></i> Modifier type des éléments';
      itemsTypeBtn.addEventListener('click', async () => {
        const t = prompt('Type des éléments (string, number, integer, boolean, object, array):', (schema.items && schema.items.type) || 'string');
        if (!t) return;
        try { setNodeType(itemsPtr, t.trim()); await persistChanges(); renderAll(); } catch (e) { alert('Impossible de changer le type des éléments.'); }
      });
      const itemsTitleBtn = document.createElement('button');
      itemsTitleBtn.type = 'button';
      itemsTitleBtn.className = 'btn btn-sm btn-outline-secondary';
      itemsTitleBtn.innerHTML = '<i class="bi bi-type"></i> Modifier titre des éléments';
      itemsTitleBtn.addEventListener('click', async () => {
        const cur = (schema.items && (schema.items.title || schema.items.titre)) || '';
        const t = prompt('Titre des éléments:', cur);
        if (t === null) return;
        try { setNodeTitle(itemsPtr, t); await persistChanges(); renderAll(); } catch (e) { alert('Impossible de changer le titre des éléments.'); }
      });
      const arrTitleBtn = document.createElement('button');
      arrTitleBtn.type = 'button';
      arrTitleBtn.className = 'btn btn-sm btn-outline-secondary';
      arrTitleBtn.innerHTML = '<i class="bi bi-type"></i> Modifier titre (liste)';
      arrTitleBtn.addEventListener('click', async () => {
        const cur = schema.title || '';
        const t = prompt('Titre de la liste:', cur);
        if (t === null) return;
        try { setNodeTitle(ptr, t); await persistChanges(); renderAll(); } catch (e) { alert('Impossible de modifier le titre de la liste.'); }
      });
      arrToolbar.appendChild(itemsTypeBtn);
      arrToolbar.appendChild(itemsTitleBtn);
      arrToolbar.appendChild(arrTitleBtn);
      body.appendChild(arrToolbar);
      const addBtn = document.createElement('button');
      addBtn.type = 'button';
      addBtn.className = 'btn btn-sm btn-outline-primary add-array-item mb-2';
      addBtn.innerHTML = '<i class="bi bi-plus-circle"></i> Ajouter';
      body.insertBefore(addBtn, list);
      const itemName = normalizeName(schema.items.title || name);
      const itemPath = path === 'root' ? itemName : `${path}.${itemName}`;
      const addItem = () => {
        const idx = list.children.length;
        const wrapper = document.createElement('div');
        wrapper.className = 'mb-2';
        const childPtr = `${ptr}/items`;
        renderSchemaAccordion(schema.items, wrapper, `${name}[${idx}]`, itemPath, schema.items.required || [], childPtr);
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'btn btn-sm btn-outline-danger remove-array-item ms-2';
        removeBtn.innerHTML = '<i class="bi bi-trash"></i>';
        removeBtn.addEventListener('click', () => wrapper.remove());
        wrapper.appendChild(removeBtn);
        list.appendChild(wrapper);
      };
      addBtn.addEventListener('click', addItem);
      addItem();
    }
  }

  function renderSchemaGraph(schema) {
    const width = schemaGraphEl.clientWidth;
    const height = 400;
    const svg = d3.select(schemaGraphEl).append('svg').attr('width', width).attr('height', height);
    const g = svg.append('g');
    const zoom = d3.zoom().on('zoom', (event) => {
      g.attr('transform', event.transform);
    });
    svg.call(zoom);

    function createNodes(node, depth = 0, parent = null, path = 'root') {
      const name = node.title || path.split('.').pop();
      const current = { name, type: node.type, depth, parent, children: [] };
      if (node.type === 'object' && node.properties) {
        const entries = Object.entries(node.properties);
        const mdOrder = getMdOrder(path);
        entries.sort(([ak, av], [bk, bv]) => {
          const nameA = normalizeName(av.title || ak);
          const nameB = normalizeName(bv.title || bk);
          const ia = mdOrder.indexOf(nameA);
          const ib = mdOrder.indexOf(nameB);
          const posA = ia !== -1 ? ia : getMarkdownIndex(nameA);
          const posB = ib !== -1 ? ib : getMarkdownIndex(nameB);
          return posA - posB;
        });
        for (const [k, v] of entries) {
          const childName = normalizeName(v.title || k);
          const childPath = path === 'root' ? childName : `${path}.${childName}`;
          current.children.push(createNodes(v, depth + 1, current, childPath));
        }
      } else if (node.type === 'array' && node.items) {
        const itemName = normalizeName(node.items.title || name);
        const childPath = path === 'root' ? itemName : `${path}.${itemName}`;
        current.children.push(createNodes(node.items, depth + 1, current, childPath));
      }
      return current;
    }

    const root = createNodes(schema);
    const treeLayout = d3.tree().nodeSize([70, 40]);
    const rootHierarchy = d3.hierarchy(root, d => d.children);
    treeLayout(rootHierarchy);

    const link = g.selectAll('.link')
      .data(rootHierarchy.links())
      .enter()
      .append('path')
      .attr('class', 'link')
      .attr('fill', 'none')
      .attr('stroke', '#ccc')
      .attr('d', d3.linkHorizontal()
        .x(d => d.y)
        .y(d => d.x));

    const node = g.selectAll('.node')
      .data(rootHierarchy.descendants())
      .enter()
      .append('g')
      .attr('class', 'node')
      .attr('transform', d => `translate(${d.y},${d.x})`)
      .call(d3.drag().on('start', null).on('drag', null));

    node.append('circle').attr('r', 4).attr('fill', '#007bff');
    node.append('text').attr('dy', -8).attr('x', 8).text(d => d.data.name);

    const types = ['string', 'number', 'boolean', 'array', 'object'];
    const color = d3.scaleOrdinal(d3.schemeCategory10).domain(types);
    const legend = svg.append('g').attr('transform', `translate(${width - 100},20)`);
    types.forEach((t,i) => {
      const lg = legend.append('g').attr('transform', `translate(0,${i*20})`);
      lg.append('rect').attr('width',12).attr('height',12).attr('fill', color(t));
      lg.append('text').attr('x',18).attr('y',10).text(t);
    });

    const box = g.node().getBBox();
    const marginLeft = 20;
    const scale = Math.min(width / (box.width + marginLeft), height / (box.height + 20));
    const x = (width - box.width * scale) / 2 - box.x * scale + marginLeft;
    const y = (height - box.height * scale) / 2 - box.y * scale;
    svg.call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
  }

  function buildTree(schema) {
    // Local $ref resolver (safety net for graph), resolves pointers against schemaData
    function getFromPointer(ptr) {
      if (!ptr || typeof ptr !== 'string' || !ptr.startsWith('#/')) return null;
      const parts = ptr.slice(2).split('/');
      let cur = schemaData;
      for (const p of parts) {
        const key = p.replace(/~1/g, '/').replace(/~0/g, '~');
        if (cur && typeof cur === 'object' && key in cur) cur = cur[key];
        else return null;
      }
      return cur || null;
    }
    function clone(obj) { try { return JSON.parse(JSON.stringify(obj)); } catch { return obj; } }
    function resolveRefLocal(n) {
      if (!n || typeof n !== 'object') return n;
      if (n.$ref) {
        const target = getFromPointer(n.$ref);
        if (target) {
          const merged = Object.assign({}, clone(target));
          for (const [k, v] of Object.entries(n)) { if (k !== '$ref') merged[k] = v; }
          return merged;
        }
      }
      return n;
    }
    function walk(node, name, path) {
      // Ensure $ref resolved for graph building even if upstream missed any
      node = resolveRefLocal(node);
      const out = { name, type: node.type || 'any' };
      if (node.type === 'object' && node.properties) {
        const entries = Object.entries(node.properties);
        const mdOrder = getMdOrder(path);
        entries.sort(([ak, av], [bk, bv]) => {
          const nameA = normalizeName(av.title || ak);
          const nameB = normalizeName(bv.title || bk);
          const ia = mdOrder.indexOf(nameA);
          const ib = mdOrder.indexOf(nameB);
          const posA = ia !== -1 ? ia : getMarkdownIndex(nameA);
          const posB = ib !== -1 ? ib : getMarkdownIndex(nameB);
          return posA - posB;
        });
        out.children = entries.map(([k,v]) => {
          v = resolveRefLocal(v);
          const childName = normalizeName(v.title || k);
          const childPath = path === 'root' ? childName : `${path}.${childName}`;
          return walk(v, k, childPath);
        });
      } else if (node.type === 'array' && node.items) {
        const items = resolveRefLocal(node.items);
        const itemName = normalizeName(items.title || name);
        const childPath = path === 'root' ? itemName : `${path}.${itemName}`;
        out.children = [walk(items, name + '[]', childPath)];
      }
      return out;
    }
    return walk(schema, schema.title || 'root', 'root');
  }

  function enhanceMarkdownLists(root) {
    if (!root) return;
    root.querySelectorAll('ul').forEach((ul) => {
      const addBtn = document.createElement('button');
      addBtn.type = 'button';
      addBtn.className = 'btn btn-sm btn-outline-primary add-list-item mb-2';
      addBtn.innerHTML = '<i class="bi bi-plus-circle"></i> Ajouter';
      ul.parentNode.insertBefore(addBtn, ul);
      addBtn.addEventListener('click', () => {
        const li = document.createElement('li');
        li.contentEditable = 'true';
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'btn btn-sm btn-outline-danger ms-2 remove-list-item';
        removeBtn.innerHTML = '<i class="bi bi-trash"></i>';
        removeBtn.addEventListener('click', () => li.remove());
        li.appendChild(removeBtn);
        ul.appendChild(li);
      });
      ul.querySelectorAll('li').forEach((li) => {
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'btn btn-sm btn-outline-danger ms-2 remove-list-item';
        removeBtn.innerHTML = '<i class="bi bi-trash"></i>';
        removeBtn.addEventListener('click', () => li.remove());
        li.appendChild(removeBtn);
      });
    });
  }

  let currentSchema = normalizePlanSchema(schemaData);
  // --- Pointer helpers over raw schemaData ---
  function getByPointer(root, ptr) {
    if (!ptr || ptr === '#' || ptr === '#/') return root;
    if (!ptr.startsWith('#/')) return null;
    const parts = ptr.slice(2).split('/').map(p => p.replace(/~1/g,'/').replace(/~0/g,'~'));
    let cur = root;
    for (const p of parts) {
      if (cur && typeof cur === 'object' && p in cur) cur = cur[p]; else return null;
    }
    return cur;
  }
  function ensure(obj, key, init) { if (!(key in obj)) obj[key] = (typeof init === 'function' ? init() : init); return obj[key]; }
  function addObjectProperty(ptr, key, value) {
    const node = getByPointer(schemaData, ptr);
    if (!node) throw new Error('ptr');
    if (node.type !== 'object') node.type = 'object';
    const props = ensure(node, 'properties', {});
    if (props[key]) throw new Error('exists');
    props[key] = value || { type: 'string', title: key };
  }
  function setNodeType(ptr, t) {
    const node = getByPointer(schemaData, ptr);
    if (!node || typeof node !== 'object') throw new Error('ptr');
    const type = (t || '').toLowerCase();
    if (!['string','number','integer','boolean','object','array'].includes(type)) throw new Error('type');
    node.type = type;
    if (type === 'object') {
      delete node.items;
      ensure(node, 'properties', {});
      if (!node.title) node.title = 'Objet';
    } else if (type === 'array') {
      delete node.properties;
      ensure(node, 'items', { type: 'string', title: 'Entrée' });
      if (!node.title) node.title = 'Liste';
    } else {
      delete node.properties;
      delete node.items;
    }
  }
  function setNodeDescription(ptr, text) {
    const node = getByPointer(schemaData, ptr);
    if (!node || typeof node !== 'object') throw new Error('ptr');
    if (text === null || text === undefined || text === '') delete node.description;
    else node.description = String(text);
  }
  function setNodeTitle(ptr, text) {
    const node = getByPointer(schemaData, ptr);
    if (!node || typeof node !== 'object') throw new Error('ptr');
    if (text === null || text === undefined || text === '') delete node.title;
    else node.title = String(text);
  }
  function deleteObjectProperty(ptr, key) {
    const node = getByPointer(schemaData, ptr);
    if (!node || !node.properties || !(key in node.properties)) throw new Error('missing');
    delete node.properties[key];
    // Also remove from required if present
    if (Array.isArray(node.required)) node.required = node.required.filter(k => k !== key);
  }
  function renameObjectProperty(ptr, oldKey, newKey) {
    const node = getByPointer(schemaData, ptr);
    if (!node || !node.properties || !(oldKey in node.properties)) throw new Error('missing');
    if (oldKey === newKey) return;
    if (newKey in node.properties) throw new Error('exists');
    node.properties[newKey] = node.properties[oldKey];
    delete node.properties[oldKey];
    if (Array.isArray(node.required)) {
      node.required = node.required.map(k => k === oldKey ? newKey : k);
    }
  }
  function moveProperty(srcParentPtr, key, destParentPtr, newKey) {
    const srcNode = getByPointer(schemaData, srcParentPtr);
    if (!srcNode || !srcNode.properties || !(key in srcNode.properties)) throw new Error('source introuvable');
    const val = srcNode.properties[key];
    delete srcNode.properties[key];
    if (Array.isArray(srcNode.required)) srcNode.required = srcNode.required.filter(k => k !== key);
    const dstNode = getByPointer(schemaData, destParentPtr);
    if (!dstNode) throw new Error('destination introuvable');
    if (dstNode.type !== 'object') dstNode.type = 'object';
    const props = ensure(dstNode, 'properties', {});
    const targetKey = (newKey && newKey.trim()) ? newKey.trim() : key;
    if (props[targetKey]) throw new Error('clé déjà existante dans la destination');
    props[targetKey] = val;
  }
  async function persistChanges() {
    const csrf = (document.querySelector('meta[name="csrf-token"]')||{}).getAttribute ? document.querySelector('meta[name="csrf-token"]').getAttribute('content') : null;
    const resp = await fetch(`/docx_schema/${pageId}/edit`, {
      method: 'POST',
      headers: Object.assign({ 'Content-Type': 'application/json' }, csrf ? { 'X-CSRFToken': csrf, 'X-CSRF-Token': csrf } : {}),
      body: JSON.stringify({ schema: schemaData })
    });
    if (!resp.ok) throw new Error('save');
  }
  function renderAll() {
    markdownOrderMap = buildMarkdownOrderMap(markdownData);
    pageTitleEl.textContent = currentSchema.title || '';
    document.title = currentSchema.title || document.title;
    titleEl.textContent = currentSchema.title || '';
    descEl.textContent = currentSchema.description || '';
    schemaEl.textContent = JSON.stringify(schemaData, null, 2);
    if (markdownEl && markdownData) {
      markdownEl.innerHTML = window.marked.parse(markdownData);
      enhanceMarkdownLists(markdownEl);
    }
    renderSchemaAccordion(currentSchema, schemaTreeEl, 'root', 'root');
    renderSchemaGraph(currentSchema);
    if (planFormEl) {
      planFormEl.innerHTML = '';
      renderPlanCadreForm(currentSchema, planFormEl);
    }
  }
  renderAll();

  if (browseBtn && browseModal) {
    const browseSearch = document.getElementById('schemaPointerSearch');
    browseBtn.addEventListener('click', () => {
      browseTree.innerHTML = '';
      const t = buildPointerTree(currentSchema, '#');
      browseTree.appendChild(t);
      if (browseSearch) {
        browseSearch.value = '';
        browseSearch.oninput = () => filterPointerTree(browseTree, browseSearch.value);
      }
      browseModal.show();
    });
  }

  // Ouvrir le parcours de schéma
  function openBrowse() {
    if (!browseModal) return;
    browseTree.innerHTML = '';
    browseTree.appendChild(buildPointerTree(currentSchema, '#'));
    browseModal.show();
  }
  if (browseBtn && browseModal) browseBtn.addEventListener('click', openBrowse);

  if (editBtn) {
    const modal = new bootstrap.Modal(editModalEl);
    editBtn.addEventListener('click', () => {
      editTextarea.value = JSON.stringify(schemaData, null, 2);
      modal.show();
    });
    editSaveBtn.addEventListener('click', async () => {
      try {
        const updated = JSON.parse(editTextarea.value);
        const csrf = (document.querySelector('meta[name="csrf-token"]')||{}).getAttribute ? document.querySelector('meta[name="csrf-token"]').getAttribute('content') : null;
        const resp = await fetch(`/docx_schema/${pageId}/edit`, {
          method: 'POST',
          headers: Object.assign({ 'Content-Type': 'application/json' }, csrf ? { 'X-CSRFToken': csrf } : {}),
          body: JSON.stringify({ schema: updated })
        });
        if (resp.ok) {
          schemaData = updated;
          currentSchema = normalizePlanSchema(schemaData);
          renderAll();
          modal.hide();
        } else {
          try { const d = await resp.json(); alert('Erreur lors de la sauvegarde: ' + (d.error || resp.status)); }
          catch(_) { alert('Erreur lors de la sauvegarde: ' + resp.status); }
        }
      } catch (e) {
        alert('JSON invalide: ' + (e && e.message ? e.message : ''));
      }
    });
  }

  // Rename schema title
  const renameBtn = document.getElementById('schemaRenameTitleBtn');
  if (renameBtn) {
    renameBtn.addEventListener('click', async () => {
      const cur = (schemaData && (schemaData.title || schemaData.titre)) || '';
      const t = prompt('Nouveau titre du schéma:', cur);
      if (!t || t === cur) return;
      if (!schemaData || typeof schemaData !== 'object') schemaData = {};
      schemaData.title = t;
      try {
        await persistChanges();
        currentSchema = normalizePlanSchema(schemaData);
        renderAll();
      } catch (e) { alert('Impossible d\'enregistrer le titre'); }
    });
  }
});
</script>
{% endblock %}
