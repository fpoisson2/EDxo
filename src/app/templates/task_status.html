{% extends "base.html" %}
{% block title %}Suivi de la tâche: {{ task_id }}{% endblock %}

{% block head_extra %}
{# Add Prism.js CSS (choose a theme) - using CDN for simplicity #}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" integrity="sha512-mIs9kKbaw6JZFfSuo+MovjU+Ntggfoj8RwAmJbVXQ5mkAX5LlgETQEweFPI18humSPHymTb5iikEOKWF7I8ncQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<style>
  /* Optional: Style the result area */
  #result-area pre {
    max-height: 60vh; /* Limit height and make scrollable */
    overflow: auto;
    background-color: #272822; /* Matches okaidia theme */
    padding: 1em;
    border-radius: 0.3em;
  }
  .status-message {
      font-weight: bold;
  }
  .status-success { color: green; }
  .status-error { color: red; }
  .status-pending { color: orange; }
  .status-progress { color: blue; }
</style>
{% endblock %}


{% block content %}
<div class="container mt-4">
  <h1>Suivi de la tâche</h1>
  <p><strong>ID de la tâche :</strong> <span id="task-id">{{ task_id }}</span></p>
  <p>
    <strong>Statut :</strong>
    <span id="task-status" class="status-message status-{{ state|lower }}">{{ state }}</span>
    <span id="loading-indicator" style="display: none;"> ( Rafraîchissement en cours<span class="dots">...</span> )</span>
  </p>

  <div id="result-area">
    <h2>Résultat :</h2>
    {% if result and result.status == 'success' %}
      {# Render initial result if already successful #}
      <pre><code class="language-json">{{ result.result | tojson(indent=2) }}</code></pre>
    {% elif result and result.status == 'error' %}
      <div class="alert alert-danger" role="alert">
        <strong>Erreur :</strong> {{ result.message }}
      </div>
    {% else %}
      <p id="result-placeholder">En attente du résultat...</p>
      <pre id="result-pre" style="display:none;"><code class="language-json"></code></pre>
      <div id="error-alert" class="alert alert-danger" role="alert" style="display:none;">
        <strong>Erreur :</strong> <span id="error-message"></span>
      </div>
    {% endif %}
  </div>

  <p class="mt-3"><a href="{{ url_for('grille_bp.import_grille') }}" class="btn btn-secondary">Revenir à l'import</a></p>
</div>
{% endblock %}

{% block scripts_extra %}
{# Add Prism.js JS - using CDN for simplicity #}
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js" integrity="sha512-9khQRAUBYEJDCDVP2ywQ0LRUbnMTIyrwpjNydAN6OJUrMAWLI2ekKS7dsSZjg/FU3Om6iQ5EFMbbIR/rDdJckA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js" integrity="sha512-fTl/qcO1V4MAoPBZ3eTuZG6kbAfBE5Cv+CkxWzl7A+wkoquydQPboPIOqrsX7RbDDflVoBUSkerMchGu29ledw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const taskId = document.getElementById('task-id').textContent;
    const taskStatusSpan = document.getElementById('task-status');
    const loadingIndicator = document.getElementById('loading-indicator');
    const resultPlaceholder = document.getElementById('result-placeholder');
    const resultPre = document.getElementById('result-pre');
    const resultCode = resultPre.querySelector('code');
    const errorAlert = document.getElementById('error-alert');
    const errorMessageSpan = document.getElementById('error-message');

    let intervalId = null;
    const pendingStates = ['PENDING', 'STARTED', 'RETRY']; // Add any other non-final states

    function updateStatus() {
      // Show loading indicator only if polling is active
       if (intervalId) {
            loadingIndicator.style.display = 'inline';
            // Animate dots (simple example)
            const dots = loadingIndicator.querySelector('.dots');
            dots.textContent = dots.textContent.length < 3 ? dots.textContent + '.' : '.';
       }


      fetch(`/task_status_api/${taskId}`) // Use the new API endpoint URL
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          // Update status text and class
          taskStatusSpan.textContent = data.state;
          taskStatusSpan.className = `status-message status-${data.state.toLowerCase()}`; // Update class for color

          if (data.state === 'SUCCESS') {
             stopPolling();
             const taskOutput = data.result; // This is the dict {'status': 'success', 'result': 'json string', ...}

             if (taskOutput && taskOutput.status === 'success') {
                // Display successful result
                resultPlaceholder.style.display = 'none';
                errorAlert.style.display = 'none';
                try {
                    // Attempt to parse and re-stringify for consistent formatting
                    const prettyJson = JSON.stringify(JSON.parse(taskOutput.result), null, 2);
                    resultCode.textContent = prettyJson;
                } catch(e) {
                    // If parsing fails, show raw text but log error
                    console.error("Failed to parse result JSON, displaying raw:", e);
                    resultCode.textContent = taskOutput.result;
                }
                resultPre.style.display = 'block';
                // IMPORTANT: Highlight AFTER adding the content
                Prism.highlightElement(resultCode);
             } else {
                 // Handle case where task succeeded but operation within failed
                 showError(taskOutput ? taskOutput.message : "La tâche s'est terminée mais a renvoyé un statut d'échec interne.");
             }

          } else if (data.state === 'FAILURE') {
            stopPolling();
            const failureMsg = (data.result && data.result.message) ? data.result.message : "La tâche a échoué sans message détaillé.";
            showError(failureMsg);

          } else if (pendingStates.includes(data.state)) {
            // Task still running, continue polling
            // Optionally display progress message if available
            if (data.result && data.result.message) {
                resultPlaceholder.textContent = data.result.message;
            } else {
                 resultPlaceholder.textContent = "Tâche en cours d'exécution...";
            }
          } else {
             // Handle other potential states (REVOKED, etc.)
             stopPolling();
             resultPlaceholder.textContent = `Statut inattendu: ${data.state}`;
          }
        })
        .catch(error => {
          console.error('Error fetching task status:', error);
          showError(`Erreur lors de la récupération du statut: ${error.message}`);
          // Optionally stop polling on fetch errors
          // stopPolling();
        })
        .finally(() => {
             // Hide loading indicator immediately after fetch completes,
             // unless polling is still active and will show it again next tick
             if (!intervalId) {
                 loadingIndicator.style.display = 'none';
             }
        });
    }

    function showError(message) {
        resultPlaceholder.style.display = 'none';
        resultPre.style.display = 'none';
        errorMessageSpan.textContent = message;
        errorAlert.style.display = 'block';
    }

    function stopPolling() {
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
        loadingIndicator.style.display = 'none'; // Ensure indicator is hidden when stopped
        console.log("Polling stopped.");
      }
    }

    // Start polling only if the initial state is pending
    const initialState = taskStatusSpan.textContent.trim().toUpperCase();
    if (pendingStates.includes(initialState)) {
      intervalId = setInterval(updateStatus, 3000); // Poll every 3 seconds
      console.log("Polling started...");
      // Initial call to update status immediately
      updateStatus();
    } else if (initialState === 'SUCCESS') {
        // If already successful on page load, ensure highlighting is applied
        Prism.highlightElement(resultCode);
    } else if (initialState === 'FAILURE') {
        // If already failed on page load, ensure error is shown correctly
        // (Assuming error message is already rendered by Jinja if available)
        const initialErrorMsg = document.getElementById('error-message');
         if(initialErrorMsg && initialErrorMsg.textContent) {
            errorAlert.style.display = 'block';
            resultPlaceholder.style.display = 'none';
         }
    }

  });
</script>
{% endblock %}